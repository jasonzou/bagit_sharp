using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO.Compression;

namespace bagit_sharp
{
    public class Bag
    {
        //setting up private values

        private DateTime pBagging_Date = DateTime.Now;
        private System.Collections.Hashtable pBag_Info_Headers = new System.Collections.Hashtable();
        private string pBag_Path = "";

        //specified encoding must be UTF8, no BOM
        private System.Text.Encoding default_encoding = new UTF8Encoding(false);
        private string pBag_Version = "0.97";
        private string pTag_File_Character_Encoding = "UTF-8";
        private string pErrorMessage = "";

        //internal types
        internal struct Info_Object
        {
            internal string object_label;
            internal string object_value;

            internal Info_Object(string plabel = "", string pvalue = "")
            {
                object_label = plabel;
                object_value = pvalue;
            }
        }

        //Private Hash
        //this may need to be a variable and not a property
        private System.Collections.Hashtable Bag_Info_Headers
        {
            get { return pBag_Info_Headers; }
            set { pBag_Info_Headers = value; }
        }
        private System.Collections.ArrayList baginfo_order = new System.Collections.ArrayList();

        //Delegates
        public delegate void StatusMessage(object sender, string message);

        //enums
        public enum CHECKSUM_ALGOS { md5 = 0, sha1, sha256, sh384, sha512 };
        public enum ZIP_TYPES { zip = 0 };


        //Public Properties

        /// <summary>
        /// Bag_Version returns the version number of 
        /// the current loaded bag.  If multiple Bag_Version statements 
        /// exist in the info file, the tool will return the first one.
        /// </summary>
        public string Bag_Version
        {
            get { return pBag_Version; }
            set { pBag_Version = value; }
        }

        /// <summary>
        /// Returns the File Character Encoding defined in the tagmanifest for the 
        /// current loaded bag.
        /// </summary>
        public string Tag_File_Character_Encoding
        {
            get { return pTag_File_Character_Encoding; }
            set
            {
                pTag_File_Character_Encoding = value;
                //this should also set default_encoding
                try
                {
                    System.Text.Encoding tenc = System.Text.Encoding.GetEncoding(value.ToLower());
                    default_encoding = tenc;
                }
                catch
                {
                    //keep default encoding as utf8
                }
            }
        }
        public string ErrorMessage
        {
            private set { pErrorMessage = value; }
            get { return pErrorMessage; }
        }

        public event StatusMessage UpdateStatus;
        public string Bag_Path
        {
            get { return pBag_Path; }
            set { pBag_Path = value; }
        }


        public Bag(string _inst_path = null)
        {
            if (_inst_path != null && System.IO.Directory.Exists(_inst_path))
            {
                Bag_Path = _inst_path;
                if (Bag_Path.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()) == false)
                {
                    Bag_Path += System.IO.Path.DirectorySeparatorChar.ToString();
                }
                load_bag_info(Bag_Path);
            }
            else if (_inst_path != null && !System.IO.Directory.Exists(_inst_path))
            {
                ErrorMessage = "specified bag path not located";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
        }

        /// <summary>
        /// Returns the Bagging Date for the currently loaded Bag.  If multiple dates are present in the 
        /// info file, the library returns the first.  If you need access to all dates, use the 
        /// get_bag_info("your_tag") function
        /// </summary>
        /// <param name="val"></param>
        /// <returns></returns>
        public DateTime? Bagging_Date(DateTime? val = null)
        {
            if (val == null)
            {
                //get operation
                System.Collections.ArrayList tlist = get_bag_info("bagging-date");
                if (tlist != null)
                {
                    return DateTime.Parse(((Info_Object)tlist[0]).object_value);
                }
                else
                {
                    return null;
                }
            }
            else
            {

                DateTime t = (System.DateTime)val;
                set_bag_info("bagging-date", t.ToString("yyyy-MM-dd"), 0);
                return t;
            }
        }

        //Autogenerated; return only
        /// <summary>
        /// Returns the Payload_Oxum for the currently loaded Bag.  If multiple oxum elements are present
        /// in the bag info, the library returns the first.  If you need access to all oxum elements, use 
        /// the get_bag_info("your_tag") function
        /// </summary>
        /// <param name="val"></param>
        /// <returns></returns>
        public string Payload_Oxum(string val = null)
        {
            EventPump("Payload_Oxum in property: " + val);
            if (val == null)
            {
                //get operation

                System.Collections.ArrayList tlist = get_bag_info("payload-oxum");
                if (tlist != null)
                {
                    return ((Info_Object)tlist[0]).object_value;
                }
                else
                {
                    return "";
                }
            }
            else
            {

                set_bag_info("payload-oxum", val, 0);
                return val;
            }
        }

        //Automatically generated; return only
        /// <summary>
        /// Returns the Bag-Size for the currently loaded bag.  If multiple bag-size elements are 
        /// in the info file, the tool will return the first element.  If you need access to all 
        /// the bag-size values, use the get_bag_info("your_value") function
        /// </summary>
        /// <param name="val"></param>
        /// <returns></returns>
        public string Bag_Size(string val = null)
        {
            if (val == null)
            {
                //get operation
                System.Collections.ArrayList tlist = get_bag_info("bag-size");
                if (tlist != null)
                {
                    try
                    {
                        return ((Info_Object)tlist[0]).object_value;
                    }
                    catch
                    {
                        return "";
                    }
                }
                else
                {
                    return "";
                }
            }
            else
            {
                set_bag_info("bag-size", val, 0);
                return val;
            }
        }
        

        private Hashtable read_tagged_file(string v, System.Text.Encoding enc, bool bpreserve_order = false)
        {
            if (bpreserve_order == true)
            {
                baginfo_order.Clear();
            }
            string sline = "";
            System.Collections.Hashtable lhash = new Hashtable();
            System.Collections.ArrayList tlist = new System.Collections.ArrayList();
            System.IO.StreamReader reader = new System.IO.StreamReader(v, enc, false);
            bool bstoploop = false;
            while (reader.Peek() > -1)
            {
                bstoploop = false;
                sline = reader.ReadLine();
                do
                {
                    int ipeak = reader.Peek();
                    if (ipeak > -1 && (ipeak == 32 || ipeak == 9))
                    {
                        sline += " " + reader.ReadLine().Trim();
                        EventPump("Line: " + sline + ": " + ipeak.ToString());
                        //new line continued
                    } else
                    {
                        bstoploop = true;
                    }
                } while (bstoploop == false);
                if (sline.Trim().Length > 0)
                {
                    string[] parts = sline.Split(":".ToCharArray());
                    if (parts.Length == 2)
                    {
                        if (bpreserve_order == true)
                        {
                            baginfo_order.Add(parts[0]);
                        }
                        if (!lhash.ContainsKey(parts[0].ToLower()))
                        {
                            Info_Object obj_p = new Info_Object();
                            obj_p.object_label = parts[0];
                            obj_p.object_value = parts[1].Trim();
                            tlist = new System.Collections.ArrayList();
                            tlist.Add(obj_p);
                            lhash.Add(parts[0].ToLower(), tlist);
                        }
                        else
                        {
                            Info_Object obj_p = new Info_Object();
                            obj_p.object_label = parts[0];
                            obj_p.object_value = parts[1].Trim();
                            tlist = (System.Collections.ArrayList)lhash[parts[0].ToLower()];
                            tlist.Add(obj_p);
                            lhash[parts[0].ToLower()] = tlist;

                        }
                    }
                }
            }
            reader.Close();
            return lhash;
        }
        #region "Property Bag"
        /// <summary>
        /// Private function to set bag properties.
        /// </summary>
        /// <param name="headers">[Optional HashTable]Following values are valid:
        /// Source-Organization
        /// Organization-Address
        /// Contact-Name
        /// Contact-Phone
        /// Contact-Email
        /// External-Description
        /// External-Identifier
        /// Bag-Group-Identifier
        /// Internal-Sender-Identifier
        /// Internal-Sender-Description
        /// BagIt-Profile-Identifier
        /// </param>
        public void SetBagProperties(System.Collections.Hashtable headers)
        {
            if (headers != null)
            {
                foreach (string key in headers.Keys)
                {
                    if (!Bag_Info_Headers.ContainsKey(key.ToLower()))
                    {
                        Bag_Info_Headers.Add(key.ToLower(), null);
                    }
                    Bag_Info_Headers[key.ToLower()] = (System.Collections.ArrayList)headers[key];
                }
            }
        }

        private void RefreshBagProperties()
        {
            //System.Collections.Hashtable bhash = new System.Collections.Hashtable();
            if (Bag_Info_Headers.ContainsKey("bagging-date"))
            {
                set_bag_info("bagging-date", DateTime.Now.ToString("yyyy-MM-dd"), 0);
            }

            if (Bag_Info_Headers.ContainsKey("bag-size"))
            {
                EventPump("Processing Bag-size in refresh");
                set_bag_info("bag-size", FormatBytes((long)System.Convert.ToDouble(Bag_Size())), 0);
                EventPump("Bag-size processed in refresh");
            }
        }


        /// <summary>
        /// Sets data in the bag info.  If index is present, the function will replace the 
        /// value at the specified index.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="svalue"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public bool set_bag_info(string tag, string svalue, int index = 0)
        {
            if (!Bag_Info_Headers.ContainsKey(tag.ToLower()))
            {
                if (index == 0)
                {
                    add_to_header(tag, svalue);
                    return true;
                }
                else
                {
                    return false;
                }
            }
            if ((((System.Collections.ArrayList)Bag_Info_Headers[tag.ToLower()]).Count - 1) < index)
            {
                return false;
            }
            else
            {
                System.Collections.ArrayList tlist = ((System.Collections.ArrayList)Bag_Info_Headers[tag.ToLower()]);
                tlist[index] = new Info_Object(tag, svalue);
                Bag_Info_Headers[tag.ToLower()] = tlist;
                return true;
            }
        }

        /// <summary>
        /// Sets bag info using an array.
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="values"></param>
        public void set_bag_info(string tag, System.Collections.ArrayList values)
        {
            System.Collections.ArrayList tlist = new System.Collections.ArrayList();
            foreach (string v in values)
            {
                if (!Bag_Info_Headers.ContainsKey(tag.ToLower()))
                {
                    Bag_Info_Headers.Add(tag.ToLower(), null);
                }
                Info_Object pinfo = new Info_Object();
                pinfo.object_label = tag;
                pinfo.object_value = v;
                tlist.Add(pinfo);
            }
            Bag_Info_Headers[tag.ToLower()] = tlist;
        }

        /// <summary>
        /// Adds a new element to the bag info
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="svalue"></param>
        public void add_to_header(string tag, string svalue)
        {
            System.Collections.ArrayList tlist = new System.Collections.ArrayList();
            if (!Bag_Info_Headers.ContainsKey(tag.ToLower()))
            {
                Bag_Info_Headers.Add(tag.ToLower(), null);
            }
            else
            {
                tlist = (System.Collections.ArrayList)Bag_Info_Headers[tag.ToLower()];
            }

            tlist.Add(new Info_Object(tag, svalue));
            Bag_Info_Headers[tag.ToLower()] = tlist;
        }

        /// <summary>
        /// remove all elements for a tag in the bag_info
        /// </summary>
        /// <param name="tag"></param>
        public void remove_bag_info(string tag)
        {
            if (Bag_Info_Headers.ContainsKey(tag.ToLower()))
            {
                Bag_Info_Headers.Remove(tag.ToLower());
            }
        }

        /// <summary>
        /// remove a specific element from the bag info at the specified index
        /// </summary>
        /// <param name="tag"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public bool remove_from_header(string tag, int index)
        {
            if (Bag_Info_Headers.ContainsKey(tag.ToLower()))
            {
                System.Collections.ArrayList tlist = new System.Collections.ArrayList();
                tlist = (System.Collections.ArrayList)Bag_Info_Headers[tag.ToLower()];
                if ((tlist.Count - 1) < index)
                {
                    return false;
                }
                else
                {
                    tlist.RemoveAt(index);
                    Bag_Info_Headers[tag.ToLower()] = tlist;
                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Get a list of all elements with a specific tag
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        public System.Collections.ArrayList get_bag_info(string tag)
        {


            if (Bag_Info_Headers.ContainsKey(tag.ToLower()))
            {
                System.Collections.ArrayList xlist = new System.Collections.ArrayList();
                System.Collections.ArrayList plist = (System.Collections.ArrayList)Bag_Info_Headers[tag.ToLower()];
                foreach (Info_Object pinfo in plist)
                {
                    xlist.Add(pinfo);
                }
                return xlist;
            }
            else
            {
                return null;
            }


        }

        /// <summary>
        /// Load the specififed bag and do light validation on load.
        /// </summary>
        /// <param name="s"></param>
        private void load_bag_info(string s)
        {
            //first, let's load the bagit.txt file to find encoding
            //always utf8
            System.Collections.Hashtable taghash = read_tagged_file(s + "bagit.txt", new System.Text.UTF8Encoding(false));
            if (taghash.ContainsKey("bagit-version"))
            {
                Bag_Version = ((Info_Object)((System.Collections.ArrayList)taghash["bagit-version"])[0]).object_value;
                //Bag_Version = (string)taghash["bagit-version"];
            }
            else if (taghash.ContainsKey("tag-file-character-encoding"))
            {
                //Tag_File_Character_Encoding = (string)taghash["tag-file-character-encoding"];
                Tag_File_Character_Encoding = ((Info_Object)((System.Collections.ArrayList)taghash["tag-file-character-encoding"])[0]).object_value;
            }

            if (Bag_Version == "0.96" ||
                Bag_Version == "0.97")
            {
                //need to implement
                //just load the bag info into the object
                if (System.IO.File.Exists(s + "bag-info.txt") == false)
                {
                    ErrorMessage = "bag-info.txt not located.";
                    EventPump(ErrorMessage);                    
                } else
                {
                    System.Collections.Hashtable headers = read_tagged_file(s + "bag-info.txt", default_encoding, true);
                    SetBagProperties(headers);
                }
            } else
            {
                if (System.IO.File.Exists(s + "package-info.txt")== false)
                {
                    ErrorMessage = "package-info.txt not located.";
                    EventPump(ErrorMessage);
                } else
                {
                    System.Collections.Hashtable headers = read_tagged_file(s + "package-info.txt", default_encoding, true);
                    SetBagProperties(headers);
                }

            }

            if (System.IO.File.Exists(s + "bagit.txt") == false)
            {
                ErrorMessage = "bagit.txt not located";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
        }

        #endregion

        #region "Zip Bag/Unzip Bag"
        public bool isZipFile(string dir = "", string sdest = "", bool bGenerateChecksum = true)
        {
            string zip_file_name = "";
            if (dir.Trim().Length == 0)
            {
                dir = this.Bag_Path;
            }

            if (sdest.Trim().Length == 0)
            {
                //you have to remove the directory separator to get the 
                //parent directory for some reason
                // sdest = System.IO.Directory.GetParent(dir.TrimEnd(new char[] { System.IO.Path.DirectorySeparatorChar })).FullName;

                if (sdest.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()) == false)
                {
                    sdest += System.IO.Path.DirectorySeparatorChar.ToString();
                }
            }

            zip_file_name = sdest + new System.IO.DirectoryInfo(dir).Name + ".zip";

            try
            {
                ZipFile.CreateFromDirectory(dir, zip_file_name, CompressionLevel.Fastest, true);

                if (bGenerateChecksum == true)
                {
                    //make a checksum
                    string zip_hash = CalcManifest(zip_file_name, CHECKSUM_ALGOS.md5);
                    System.IO.File.Create(sdest + zip_hash + ".md5").Close();
                    EventPump("zip file made");
                }
                return true;
            }
            catch (System.Exception ex)
            {
                ErrorMessage = ex.ToString();
                EventPump(ErrorMessage);
                return false;
            }
        }
        #endregion

        #region "Make Bag Function"
        /// <summary>
        /// Converts a given directory to a bag.  Bag information should be set either 
        /// when the class is created, or via the bag properties.
        /// </summary>
        /// <param name="bag_directory"></param>
        /// <param name="processes">At this point; isn't used</param>
        /// <param name="checksum"></param>
        /// <returns></returns>
        public Bag Make_Bag(string[] objects_to_bag,
            string bag_directory,
            System.Collections.Hashtable headers = null,
            int processes = -1,
            CHECKSUM_ALGOS checksum = CHECKSUM_ALGOS.md5)
        {

            if (headers != null && headers.Count > 0)
            {
                SetBagProperties(headers);
            }

            string file_not_found = "";
            if (ObjectsExist(ref objects_to_bag, out file_not_found) == false)
            {
                ErrorMessage = "Unabled to find object" + file_not_found;
                EventPump(ErrorMessage);
                return null;
            }


            EventPump("starting bagging process");
            EventPump("checksum algorthm used" + checksum.ToString());

            //create bag directory
            try
            {
                System.IO.DirectoryInfo dinfo = System.IO.Directory.CreateDirectory(bag_directory);
                bag_directory = dinfo.FullName;
            }
            catch
            {
                bag_directory = System.Environment.CurrentDirectory + System.IO.Path.DirectorySeparatorChar + bag_directory;
                System.IO.Directory.CreateDirectory(bag_directory);
            }

            if (bag_directory.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()) == false)
            {
                bag_directory += System.IO.Path.DirectorySeparatorChar.ToString();
            }

            string data_directory = bag_directory + "data" + System.IO.Path.DirectorySeparatorChar.ToString();
            EventPump("bag is being created at: " + bag_directory);
            EventPump("creating payload data directory: " + data_directory);

            try
            {
                System.IO.Directory.CreateDirectory(data_directory);
            }
            catch
            {
                ErrorMessage = "Unable to create payload directory: " + data_directory;
                EventPump(ErrorMessage);
                return null;
            }

            bool bPreserveDir = false;

            if (objects_to_bag.Length > 1) { bPreserveDir = true; }



            foreach (string data_to_bag in objects_to_bag)
            {






                //make sure I can read and write to various locations
                string unreadable_dirs = "";
                string unreadable_files = "";


                //we stop if anything is unreadable
                if (CanRead(data_to_bag, ref unreadable_dirs, ref unreadable_files) == false)
                {
                    ErrorMessage = "Unable to read: " + data_to_bag;
                    EventPump(ErrorMessage);
                    //Remove the data_directory
                    try
                    {
                        System.IO.Directory.Delete(data_directory, true);
                    }
                    catch { }
                    return null;
                }
                else
                {
                    if (!String.IsNullOrEmpty(unreadable_dirs) || !string.IsNullOrEmpty(unreadable_files))
                    {
                        ErrorMessage = "Unreadble directories: " + unreadable_dirs + System.Environment.NewLine + "Unreadable files: " + unreadable_files;
                        EventPump(ErrorMessage);
                        //Remove the data_directory
                        try
                        {
                            System.IO.Directory.Delete(data_directory, true);
                        }
                        catch { }
                        return null;
                    }
                }

                //move files into the payload
                //track files that may have problems between
                //windows and unix based systems.

                try
                {
                    if (IsFile(data_to_bag))
                    {
                        try
                        {
                            System.IO.File.Copy(data_to_bag, data_directory + new System.IO.FileInfo(data_to_bag).Name, false);

                            try
                            {
                                //set file permissions
                                EventPump("mirroring file permissions for: " + data_to_bag);
                                System.Security.AccessControl.FileSecurity initial_file = System.IO.File.GetAccessControl(data_to_bag);
                                System.IO.File.SetAccessControl(data_directory + new System.IO.FileInfo(data_to_bag).Name, initial_file);
                            }
                            catch
                            {
                                ErrorMessage = "Unable to mirror permissions in the payload directory for the object: " + data_to_bag;
                                EventPump(ErrorMessage);
                            }
                        }
                        catch
                        {
                            ErrorMessage = "Unable to copy data: " + data_to_bag + ". Cleaning up temporary files";
                            EventPump(ErrorMessage);
                            try
                            {
                                System.IO.Directory.Delete(data_directory, true);
                            }
                            catch { }
                            return null;
                        }
                    }
                    else
                    {
                        //if (CopyFolder(data_to_bag, data_directory, false) == false)
                        string target_path = data_directory;
                        if (bPreserveDir == true)
                        {
                            target_path = data_directory + new System.IO.DirectoryInfo(data_to_bag).Name;
                            if (target_path.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()) == false)
                            {
                                target_path += System.IO.Path.DirectorySeparatorChar.ToString();
                            }
                            try
                            {
                                System.IO.Directory.CreateDirectory(target_path);
                            }
                            catch { }
                        }

                        EventPump("Copying to: " + target_path);

                        if (CopyFolder(new System.IO.DirectoryInfo(data_to_bag), new System.IO.DirectoryInfo(target_path)) == false)
                        {
                            ErrorMessage = "Unable to copy data to: " + target_path + "...cleaning up temporary files";
                            EventPump(ErrorMessage);
                            try
                            {
                                System.IO.Directory.Delete(data_directory, true);
                            }
                            catch { }
                            return null;
                        }

                        try
                        {
                            EventPump("mirroring directory permissions");
                            System.Security.AccessControl.DirectorySecurity initial_directory = System.IO.Directory.GetAccessControl(data_to_bag);
                            System.IO.Directory.SetAccessControl(data_directory, initial_directory);
                        }
                        catch
                        {
                            ErrorMessage = "Unable to mirror permissions in the payload directory for the object: " + data_to_bag;
                            EventPump(ErrorMessage);
                        }

                    }
                }
                catch
                {
                    ErrorMessage = "Unable to copy data: " + data_to_bag;
                    EventPump(ErrorMessage);
                    return null;
                }
            }


            EventPump("writing the manifest file");
            long[] vals = make_manifest(bag_directory, checksum, "utf-8", true);


            Payload_Oxum(vals[0].ToString() + "." + vals[1].ToString());
            EventPump("Payload-Oxum: " + Payload_Oxum());
            Bag_Size(vals[0].ToString());
            EventPump("Bag-Size: " + Bag_Size());

            EventPump("write bag-info file");
            bool bret = make_bag_info(bag_directory);
            bret = make_bag_txt(bag_directory);

            bret = make_tagfile(bag_directory, checksum);

            EventPump("finished");
            return new Bag(bag_directory);
        }

        private bool ObjectsExist(ref string[] objects_to_bag, out string file_not_found)
        {
            string current_directory = System.Environment.CurrentDirectory;
            bool bResolved = false;
            file_not_found = string.Empty;
            if (current_directory.EndsWith(System.IO.Path.DirectorySeparatorChar.ToString()) == false)
            {
                current_directory += System.IO.Path.DirectorySeparatorChar.ToString();
            }

            for (int x = 0; x < objects_to_bag.Length; x++)
            {
                bResolved = false; //reset this on each loop
                string item = objects_to_bag[x];
                if (System.IO.File.Exists(item) == false)
                {
                    if (System.IO.File.Exists(current_directory + item))
                    {
                        item = current_directory + item;
                        objects_to_bag[x] = item;
                        bResolved = true;
                        return true;
                    }
                }
                else
                {
                    bResolved = true;
                    return true;
                }

                if (bResolved == false)
                {
                    if (System.IO.Directory.Exists(item) == false)
                    {
                        if (System.IO.Directory.Exists(current_directory + item))
                        {
                            //found
                            item = current_directory + item;
                            objects_to_bag[x] = item;
                            bResolved = true;
                            return true;
                        }
                    }
                    else
                    {
                        bResolved = true;
                        return true;
                    }
                }

                if (bResolved == false)
                {
                    //cannot resolve the object, set the error and fail the 
                    //function
                    file_not_found = item;
                    return false;
                }
            }

            return false;
        }
        #endregion

        #region "Update Manifest"
        public Bag Update_Manifest(string _bag_path = null)
        {
            if (_bag_path == null)
            {
                if (System.IO.Directory.Exists(this.Bag_Path) == false)
                {
                    ErrorMessage = "bag path: " + Bag_Path + System.Environment.NewLine + "No Bag has been specified";
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                }
                else
                {
                    _bag_path = this.Bag_Path;
                }
            }
            else
            {
                this.Bag_Path = _bag_path;
                load_bag_info(_bag_path);
            }

            EventPump("Bag File Path: " + _bag_path);
            bool bmanifest_valid = validate_manifest_files(_bag_path);
            if (bmanifest_valid == false)
            {
                ErrorMessage = "Validation failed";
                return null;
                throw new BagException(ErrorMessage);
            }

            long[] vals = new long[2];
            foreach (string f in System.IO.Directory.GetFiles(_bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("manifest") == true)
                {
                    CHECKSUM_ALGOS checksum = select_checksum(f);
                    vals = make_updated_manifest(_bag_path, checksum);
                }
            }
            Payload_Oxum(vals[0].ToString() + "." + vals[1].ToString());
            Bag_Size(vals[0].ToString());

            EventPump("write bag-info file");
            bool bret = make_bag_info(_bag_path);
            bret = make_bag_txt(_bag_path);

            foreach (string f in System.IO.Directory.GetFiles(_bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("tagmanifest") == true)
                {
                    CHECKSUM_ALGOS checksum = select_checksum(f);
                    bret = make_tagfile(_bag_path, checksum);
                }
            }

            EventPump("finished");
            return new Bag(_bag_path);

        }
        #endregion

        #region "Validate Bag"
        public bool Validate_Bag(string _bag_path = null, bool bFast = true)
        {
            if (_bag_path == null)
            {
                if (System.IO.Directory.Exists(this.Bag_Path) == false)
                {
                    ErrorMessage = "bag path: " + Bag_Path + System.Environment.NewLine + "No Bag has been specified";
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                }
                else
                {
                    _bag_path = this.Bag_Path;
                }
            }
            else
            {
                this.Bag_Path = _bag_path;
                load_bag_info(_bag_path);
            }

            validate_structure(_bag_path);
            validate_bagittxt(_bag_path);
            validate_tagfiles(_bag_path);
            bool bmanifest_valid = validate_manifest_files(_bag_path);
            if (bmanifest_valid == false)
            {
                throw new BagException(ErrorMessage);
            }
            validate_contents(_bag_path, bFast);
            return true;
        }

        private void validate_structure(string bag_path)
        {
            if (System.IO.Directory.Exists(bag_path + "data") == false)
            {
                ErrorMessage = "Missing payload directory";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }

            if (System.IO.File.Exists(bag_path + "bagit.txt") == false)
            {
                ErrorMessage = "Missing bagit.txt file";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);

            }

            bool manifest_found = false;


            foreach (string f in System.IO.Directory.GetFiles(bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("manifest") == true)
                {
                    manifest_found = true;
                    break;
                }
            }

            if (manifest_found == false)
            {
                ErrorMessage = "Missing manifest file";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
        }
        private void validate_bagittxt(string bag_path)
        {
            System.IO.FileStream fs = new System.IO.FileStream(bag_path + "bagit.txt", System.IO.FileMode.Open);
            byte[] bits = new byte[3];
            fs.Read(bits, 0, 3);

            // UTF8 byte order mark is: 0xEF,0xBB,0xBF
            if (bits[0] == 0xEF && bits[1] == 0xBB && bits[2] == 0xBF)
            {
                fs.Close();
                ErrorMessage = "bagit.txt file must not contain BOM characters";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
            fs.Close();
        }
        private void validate_tagfiles(string bag_path)
        {
            foreach (string f in System.IO.Directory.GetFiles(bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("tagmanifest"))
                {
                    validate_tagmanifest(f);
                }
            }
        }

        private void validate_tagmanifest(string tagmanifest)
        {
            CHECKSUM_ALGOS checksum = CHECKSUM_ALGOS.md5;

            //need to determine checksum
            checksum = select_checksum(tagmanifest);

            EventPump("CheckSum selected: " + checksum.ToString());
            string sline = "";
            string parent_directory = System.IO.Path.GetDirectoryName(tagmanifest);
            System.IO.StreamReader reader = new System.IO.StreamReader(tagmanifest, default_encoding, false);
            while (reader.Peek() > -1)
            {
                sline = reader.ReadLine();
                if (sline.Trim().Length > 0)
                {
                    sline = sline.Replace("\t", " ");
                    string[] parts = new string[2];
                    if (sline.IndexOf(" ") > -1)
                    {
                        parts[0] = sline.Substring(0, sline.IndexOf(" ")).Trim();
                        parts[1] = sline.Substring(sline.IndexOf(" ")).Trim();
                        if (parts[0] != CalcManifest(System.IO.Path.Combine(parent_directory, parts[1]), checksum))
                        {
                            ErrorMessage = "tagmanifest checksum doesn't match for: " + parts[1] + System.Environment.NewLine +
                                "checksum: " + parts[0] + System.Environment.NewLine +
                                "using checksum: " + checksum.ToString() + System.Environment.NewLine +
                                CalcManifest(System.IO.Path.Combine(parent_directory, parts[1]), checksum);
                            EventPump(ErrorMessage);
                            throw new BagException(ErrorMessage);
                        }
                    }
                }
            }
            reader.Close();
        }
        private bool validate_manifest_files(string bag_path, bool bcheck_checkdigit = false)
        {
            //this just checks to see if files are duplicate 
            //this would be a problem on windows
            System.Collections.ArrayList file_list = new System.Collections.ArrayList();
            foreach (string f in System.IO.Directory.GetFiles(bag_path))
            {
                if (System.IO.Path.GetFileName(f).StartsWith("manifest") == true)
                {
                    CHECKSUM_ALGOS checksum = select_checksum(System.IO.Path.GetFileName(f));
                    string[] manifest_lines = System.IO.File.ReadAllLines(f, default_encoding);
                    foreach (string mline in manifest_lines)
                    {
                        if (mline.Trim().Length > 0)
                        {
                            string tmp_mline = mline.TrimEnd();
                            if (tmp_mline.IndexOf("\t") > -1) { tmp_mline = tmp_mline.Replace("\t", " "); }
                            string data_file = tmp_mline.Substring(tmp_mline.IndexOf(" ")).Trim();
                            string hashed_signature = tmp_mline.Substring(0, tmp_mline.IndexOf(" ")).Trim();
                            if (file_list.IndexOf(data_file.ToLower()) > -1)
                            {
                                EventPump("Potential duplicate file located.  File: " + data_file.Trim() + System.Environment.NewLine +
                                    "On Windows, file names/paths are treated as case insensitive potentially " +
                                    "leading to data loss if not changed.");
                            }
                            else
                            {
                                file_list.Add(data_file.Trim().ToLower());
                            }
                            //We need to make sure that all the files that are suppose to be in the bag, are 
                            //present -- this needs to be done before any changes to a manifest file 
                            //can be made.
                            if (!System.IO.File.Exists(bag_path + data_file.TrimStart("*./".ToCharArray()).Replace("/", System.IO.Path.DirectorySeparatorChar.ToString())))
                            {
                                ErrorMessage = "File not found: " + bag_path + data_file.TrimStart("*./".ToCharArray()).Replace("/", System.IO.Path.DirectorySeparatorChar.ToString());
                                EventPump(ErrorMessage);
                                return false;
                            }
                            
                            if (bcheck_checkdigit == true)
                            {
                                if (CalcManifest(bag_path + data_file.TrimStart("*./".ToCharArray()).Replace("/", System.IO.Path.DirectorySeparatorChar.ToString()), checksum) != hashed_signature)
                                {
                                    ErrorMessage = "File checksum does not match the manifest.  File: " + bag_path + data_file.TrimStart("*./".ToCharArray()).Replace("/", System.IO.Path.DirectorySeparatorChar.ToString());
                                    EventPump(ErrorMessage);
                                    return false;
                                } 
                            }
                        }
                    }                    
                }
            }
            return true;
        }

        private void validate_contents(string bag_path, bool bFast)
        {
            //fast just checks the oxam
            //false looks at the whole file
            if (bFast == true)
            {
                //we are just going to check the oxam against all the data
                //in the payload
                if (string.IsNullOrEmpty(Payload_Oxum()))
                {
                    ErrorMessage = "no oxum defined. cannot fast validate.";
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                }
                else
                {
                    long fcount = 0;
                    long fsize = 0;
                    foreach (string f in System.IO.Directory.GetFiles(bag_path + "data", "*.*", System.IO.SearchOption.AllDirectories))
                    {
                        fcount++;
                        fsize += new System.IO.FileInfo(f).Length;

                    }

                    string[] parts = Payload_Oxum().Split(".".ToCharArray());
                    if (parts[0] != fsize.ToString())
                    {
                        ErrorMessage = "contents do not appear to match based on the oxum evaluation";
                        EventPump(ErrorMessage);
                        throw new BagException(ErrorMessage);
                    }

                    if (parts[1] != fcount.ToString())
                    {
                        ErrorMessage = "file count doesn't match the oxum";
                        EventPump(ErrorMessage);
                        throw new BagException(ErrorMessage);
                    }
                }
            } else
            {
                if (validate_manifest_files(bag_path, true) == false)
                {
                    ErrorMessage = "Checksums don't validate";
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                }
            }
        }
        #endregion


        #region "utility functions"
        private bool make_bag_txt(string bag_directory)
        {


            System.IO.StreamWriter writer = new System.IO.StreamWriter(bag_directory + "bagit.txt", false, default_encoding);
            writer.Write("BagIt-version: " + Bag_Version + System.Environment.NewLine);
            writer.Write("Tag-File-Character-Encoding: " + default_encoding.WebName);
            writer.Close();

            return true;
        }
        private bool make_bag_info(string bag_directory)
        {
            //RefreshBagProperties();
            //System.Collections.Hashtable bag_info_hash = GetBagProperties();
            System.IO.StreamWriter writer = null;
            if (Bag_Version == "0.96" ||
                Bag_Version == "0.97")
            {
                writer = new System.IO.StreamWriter(bag_directory + "bag-info.txt", false, default_encoding);
            }
            else
            {
                writer = new System.IO.StreamWriter(bag_directory + "package-info.txt", false, default_encoding);
            }

            if (baginfo_order.Count > 0)
            {
                //preserve order
                foreach (string item in baginfo_order)
                {
                    writer.Write(item + ": " + ((Info_Object)((System.Collections.ArrayList)Bag_Info_Headers[item.ToLower()])[0]).object_value + System.Environment.NewLine);
                    remove_from_header(item, 0);
                }
                foreach (string bkey in Bag_Info_Headers.Keys)
                {
                    System.Collections.ArrayList tlist = (System.Collections.ArrayList)Bag_Info_Headers[bkey];
                    if (tlist.Count > 0)
                    {
                        foreach (Info_Object obj_i in tlist)
                        {
                            writer.Write(obj_i.object_label + ": " + obj_i.object_value + System.Environment.NewLine);
                        }
                    }
                }
            }
            else
            {
                foreach (string bkey in Bag_Info_Headers.Keys)
                {
                    System.Collections.ArrayList tlist = (System.Collections.ArrayList)Bag_Info_Headers[bkey];
                    foreach (Info_Object obj_i in tlist)
                    {
                        writer.Write(obj_i.object_label + ": " + obj_i.object_value + System.Environment.NewLine);
                    }
                }
                //foreach (string key in Bag_Info_Headers.Keys)
                //{
                //    writer.Write(key + ": " + ((System.Collections.ArrayList)Bag_Info_Headers[key.ToLower()])[0]);
                //    //writer.Write(key + ": " + (string)bag_info_hash[key] + System.Environment.NewLine);
                //}
            }
            writer.Close();
            return true;
        }
        private bool make_tagfile(string bag_directory, CHECKSUM_ALGOS checksum)
        {
            string tagmanifest_filename = "tagmanifest-" + alg(checksum) + ".txt";
            System.IO.StreamWriter writer = new System.IO.StreamWriter(bag_directory + tagmanifest_filename, false, default_encoding);
            foreach (string f in System.IO.Directory.GetFiles(bag_directory))
            {
                EventPump("Adding to the tagmanifest: " + f);
                if (f.IndexOf("tagmanifest") == -1)
                {
                    if (System.IO.Path.GetFileNameWithoutExtension(f).StartsWith("manifest") &&
                        System.IO.Path.GetFileName(f) != "manifest-" + alg(checksum) + ".txt")
                    {
                        continue;
                    }
                    string sline = CalcManifest(f, checksum) + "\t" + System.IO.Path.GetFileName(f);
                    writer.WriteLine(sline);

                }
            }
            writer.Close();
            return true;
        }

        private long[] make_updated_manifest(string dir, CHECKSUM_ALGOS checksum)
        {
            System.Collections.ArrayList manifest_file_list = new ArrayList();
            try
            {
                string manifest_filename = "manifest-" + alg(checksum) + ".txt";
                string[] manifest_lines = System.IO.File.ReadAllLines(dir + manifest_filename, default_encoding);
                foreach (string single_line in manifest_lines)
                {
                    string tmp_line = single_line.TrimEnd();
                    if (tmp_line.IndexOf("\t") > -1) { tmp_line = tmp_line.Replace("\t", " "); }
                    string data_file = tmp_line.Substring(tmp_line.IndexOf(" ")).Trim();
                    if (data_file.Trim().Length > 0)
                    {
                        manifest_file_list.Add(dir + data_file.TrimStart("*./".ToCharArray()).Replace("/", System.IO.Path.DirectorySeparatorChar.ToString()));
                    }
                }

                //all files from the manifest have been added -- now we only create a new checksum when 
                //a file doesn't show up in this list
                long directorysize = 0;
                long number_of_files = 0;
                System.IO.StreamWriter writer = new System.IO.StreamWriter(dir + manifest_filename, true, default_encoding);
                foreach (string f in System.IO.Directory.GetFiles(dir + "data", "*.*", System.IO.SearchOption.AllDirectories))
                {
                    System.IO.FileInfo finfo = new System.IO.FileInfo(f);
                    directorysize += finfo.Length;
                    number_of_files++;
                    if (manifest_file_list.IndexOf(f) == -1)
                    {
                        EventPump("calculating checksum for " + f);
                        string sline = CalcManifest(f, checksum) + "\t" + f.Substring(f.IndexOf("data")).Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "/");
                        if (string.IsNullOrEmpty(sline))
                        {
                            ErrorMessage = "Unable to locate file: " + f;
                            EventPump(ErrorMessage);
                            throw new BagException(ErrorMessage);
                        }
                        writer.Write(sline + System.Environment.NewLine);
                    }
                }
                writer.Flush();
                writer.Close();

                return new long[] { directorysize, number_of_files };
            }
            catch
            {
                ErrorMessage = "manifest cannot be updated";
                EventPump(ErrorMessage);
                throw new BagException(ErrorMessage);
            }
        }
        private long[] make_manifest(string dir, CHECKSUM_ALGOS checksum, string encoding, bool bappend = false)
        {
            string manifest_filename = "manifest-" + alg(checksum) + ".txt";


            long directorysize = 0;
            long number_of_files = 0;
            System.IO.StreamWriter writer = new System.IO.StreamWriter(dir + manifest_filename, bappend, default_encoding);
            foreach (string f in System.IO.Directory.GetFiles(dir + "data", "*.*", System.IO.SearchOption.AllDirectories))
            {
                System.IO.FileInfo finfo = new System.IO.FileInfo(f);
                directorysize += finfo.Length;
                number_of_files++;
                EventPump("calculating checksum for " + f);
                string sline = CalcManifest(f, checksum) + "\t" + f.Substring(f.IndexOf("data")).Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "/");
                if (string.IsNullOrEmpty(sline))
                {
                    ErrorMessage = "Unable to locate file: " + f;
                    EventPump(ErrorMessage);
                    throw new BagException(ErrorMessage);
                }
                writer.Write(sline + System.Environment.NewLine);
            }
            writer.Flush();
            writer.Close();

            return new long[] { directorysize, number_of_files };

        }

        private void BuildManifest(System.IO.StreamWriter writer, CHECKSUM_ALGOS checksum, string dir)
        {

            foreach (string f in System.IO.Directory.GetFiles(dir, "*.*", System.IO.SearchOption.AllDirectories))
            {
                string sline = CalcManifest(f, checksum) + "\t" + f.Substring(f.IndexOf("data") + 1).Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "/");
                writer.Write(sline + System.Environment.NewLine);
            }

            //foreach (string d in System.IO.Directory.GetDirectories(dir))
            //{
            //    BuildManifest(writer, checksum, dir);
            //}

        }
        private string CalcManifest(string file, CHECKSUM_ALGOS checksum)
        {

            if (System.IO.File.Exists(file) == false)
            {
                if (file.IndexOf("*") > -1) { file = file.Replace("*", ""); }
                if (System.IO.File.Exists(file) == false) { return null; }
            }

            switch (checksum)
            {
                case CHECKSUM_ALGOS.md5:
                    {
                        using (var md5 = System.Security.Cryptography.MD5.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }

                case CHECKSUM_ALGOS.sha1:
                    {
                        using (var sh1 = System.Security.Cryptography.SHA1.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(sh1.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }

                case CHECKSUM_ALGOS.sha256:
                    {
                        using (var sh256 = System.Security.Cryptography.SHA256.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(sh256.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }

                case CHECKSUM_ALGOS.sha512:
                    {
                        using (var sh512 = System.Security.Cryptography.SHA512.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(sh512.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }

                default:
                    {
                        using (var md5 = System.Security.Cryptography.MD5.Create())
                        {
                            using (var stream = System.IO.File.OpenRead(file))
                            {
                                return BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", "").ToLower();
                            }
                        }
                    }

            }


        }
        private bool CanRead(string dir, ref string unreadable_dirs, ref string unreadable_files)
        {

            try
            {
                if (IsFile(dir))
                {
                    try
                    {
                        System.IO.FileInfo finfo = new System.IO.FileInfo(dir);
                    }
                    catch
                    {
                        unreadable_files = dir;
                    }
                }
                else
                {
                    System.IO.DirectoryInfo dinfo = new System.IO.DirectoryInfo(dir);
                    foreach (string f in System.IO.Directory.GetFiles(dir))
                    {
                        try
                        {
                            System.IO.FileInfo finfo = new System.IO.FileInfo(f);
                        }
                        catch
                        {
                            unreadable_files += "|" + f;
                        }
                    }

                    foreach (string d in System.IO.Directory.GetDirectories(dir))
                    {
                        try
                        {
                            System.IO.DirectoryInfo d1info = new System.IO.DirectoryInfo(d);
                            CanRead(d, ref unreadable_dirs, ref unreadable_files);
                        }
                        catch
                        {
                            unreadable_dirs += "|" + d;
                        }
                    }
                }
            }
            catch
            {
                unreadable_dirs = dir;
                return false;
            }

            unreadable_dirs = unreadable_dirs.Trim("|".ToCharArray());
            unreadable_files = unreadable_files.Trim("|".ToCharArray());

            if (!string.IsNullOrEmpty(unreadable_files) || !string.IsNullOrEmpty(unreadable_dirs))
            {
                return false;
            }

            return true;
        }
        private bool IsFile(string dir)
        {
            if (System.IO.File.Exists(dir))
            {
                //its a file
                return true;
            }
            else
            {
                return false;
            }
        }
        private bool CopyFolder(System.IO.DirectoryInfo source, System.IO.DirectoryInfo target)
        {
            try
            {
                foreach (System.IO.DirectoryInfo dir in source.GetDirectories())
                    CopyFolder(dir, target.CreateSubdirectory(dir.Name));
                foreach (System.IO.FileInfo file in source.GetFiles())
                    file.CopyTo(System.IO.Path.Combine(target.FullName, file.Name), false);
            }
            catch (System.Exception e)
            {
                System.Windows.Forms.MessageBox.Show(e.ToString());
                System.Diagnostics.Debug.WriteLine(e.ToString());
                return false;
            }
            return true;
        }
        private string alg(CHECKSUM_ALGOS checksum)
        {
            switch (checksum)
            {
                case CHECKSUM_ALGOS.md5:
                    return "md5";
                case CHECKSUM_ALGOS.sha1:
                    return "sha1";
                case CHECKSUM_ALGOS.sha256:
                    return "sha256";
                case CHECKSUM_ALGOS.sh384:
                    return "sha384";
                case CHECKSUM_ALGOS.sha512:
                    return "sh5a12";
                default:
                    return "md5";
            }

        }
        private string FormatBytes(long bytes)
        {
            string[] Suffix = { "B", "KB", "MB", "GB", "TB" };
            int i;
            double dblSByte = bytes;
            for (i = 0; i < Suffix.Length && bytes >= 1024; i++, bytes /= 1024)
            {
                dblSByte = bytes / 1024.0;
            }

            return String.Format("{0:0.##} {1}", dblSByte, Suffix[i]);
        }
        private CHECKSUM_ALGOS select_checksum(string file)
        {
            CHECKSUM_ALGOS checksum = CHECKSUM_ALGOS.md5;

            //need to determine checksum
            if (file.IndexOf("md5") > -1)
            {
                checksum = CHECKSUM_ALGOS.md5;
            }
            else if (file.IndexOf("sha1") > -1)
            {
                checksum = CHECKSUM_ALGOS.sha1;
            }
            else if (file.IndexOf("sha256") > -1)
            {
                checksum = CHECKSUM_ALGOS.sha256;
            }
            else if (file.IndexOf("sha384") > -1)
            {
                checksum = CHECKSUM_ALGOS.sh384;
            }
            else if (file.IndexOf("sha512") > -1)
            {
                checksum = CHECKSUM_ALGOS.sha512;
            }

            EventPump("CheckSum selected: " + checksum.ToString());
            return checksum;
        }
        private string Regenerate_Payload_Oxum(string bag_path)
        {
            long fcount = 0;
            long fsize = 0;
            foreach (string f in System.IO.Directory.GetFiles(bag_path + "data", "*.*", System.IO.SearchOption.AllDirectories))
            {
                fcount++;
                fsize += new System.IO.FileInfo(f).Length;

            }
            return fsize.ToString() + "." + fcount.ToString();
        }
        #endregion


        internal void EventPump(string message)
        {
            System.Diagnostics.Debug.WriteLine(message);
            try
            {
                UpdateStatus(new Bag(), message);
            }
            catch { }
        }
        private void ThreadPoolCallback(Object threadContext)
        {
            int threadIndex = (int)threadContext;

        }
    }
}
